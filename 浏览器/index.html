<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器 | 面试总结学习</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="每天记录一些学习的关于面试的新知识">
    
    <link rel="preload" href="/interview/assets/css/0.styles.0d8df7ee.css" as="style"><link rel="preload" href="/interview/assets/js/app.4760c636.js" as="script"><link rel="preload" href="/interview/assets/js/2.fcc25b9e.js" as="script"><link rel="preload" href="/interview/assets/js/3.1d9d2a9b.js" as="script"><link rel="prefetch" href="/interview/assets/js/10.81c667ae.js"><link rel="prefetch" href="/interview/assets/js/11.808c1a58.js"><link rel="prefetch" href="/interview/assets/js/12.ad8bdd11.js"><link rel="prefetch" href="/interview/assets/js/13.48f39ef1.js"><link rel="prefetch" href="/interview/assets/js/14.1b787f32.js"><link rel="prefetch" href="/interview/assets/js/15.44d78914.js"><link rel="prefetch" href="/interview/assets/js/16.5af80b4c.js"><link rel="prefetch" href="/interview/assets/js/17.22b7d9ce.js"><link rel="prefetch" href="/interview/assets/js/18.7f068fb6.js"><link rel="prefetch" href="/interview/assets/js/4.c4e98d15.js"><link rel="prefetch" href="/interview/assets/js/5.ca010a6a.js"><link rel="prefetch" href="/interview/assets/js/6.3e3cc88d.js"><link rel="prefetch" href="/interview/assets/js/7.5283a369.js"><link rel="prefetch" href="/interview/assets/js/8.604d7003.js"><link rel="prefetch" href="/interview/assets/js/9.51bb396a.js">
    <link rel="stylesheet" href="/interview/assets/css/0.styles.0d8df7ee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/interview/" class="home-link router-link-active"><!----> <span class="site-name">面试总结学习</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/interview/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/interview/CSS/" class="nav-link">
  CSS 类型
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络与浏览器" class="dropdown-title"><span class="title">网络与浏览器</span> <span class="arrow down"></span></button> <button type="button" aria-label="网络与浏览器" class="mobile-dropdown-title"><span class="title">网络与浏览器</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/网络/" class="nav-link">
  网络
</a></li><li class="dropdown-item"><!----> <a href="/interview/浏览器/" class="nav-link">
  浏览器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="js/ts" class="dropdown-title"><span class="title">js/ts</span> <span class="arrow down"></span></button> <button type="button" aria-label="js/ts" class="mobile-dropdown-title"><span class="title">js/ts</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/language/js.html" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/interview/language/ts.html" class="nav-link">
  ts
</a></li></ul></div></div><div class="nav-item"><a href="/interview/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架" class="mobile-dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/frame/vue.html" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/interview/frame/react.html" class="nav-link">
  react
</a></li></ul></div></div><div class="nav-item"><a href="/interview/设计模式/" class="nav-link">
  设计模式
</a></div><div class="nav-item"><a href="/interview/工作积累/" class="nav-link">
  工作积累
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="源码学习" class="dropdown-title"><span class="title">源码学习</span> <span class="arrow down"></span></button> <button type="button" aria-label="源码学习" class="mobile-dropdown-title"><span class="title">源码学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/源码学习/vue3.html" class="nav-link">
  vue3
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/interview/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/interview/CSS/" class="nav-link">
  CSS 类型
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="网络与浏览器" class="dropdown-title"><span class="title">网络与浏览器</span> <span class="arrow down"></span></button> <button type="button" aria-label="网络与浏览器" class="mobile-dropdown-title"><span class="title">网络与浏览器</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/网络/" class="nav-link">
  网络
</a></li><li class="dropdown-item"><!----> <a href="/interview/浏览器/" class="nav-link">
  浏览器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="js/ts" class="dropdown-title"><span class="title">js/ts</span> <span class="arrow down"></span></button> <button type="button" aria-label="js/ts" class="mobile-dropdown-title"><span class="title">js/ts</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/language/js.html" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/interview/language/ts.html" class="nav-link">
  ts
</a></li></ul></div></div><div class="nav-item"><a href="/interview/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架" class="mobile-dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/frame/vue.html" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/interview/frame/react.html" class="nav-link">
  react
</a></li></ul></div></div><div class="nav-item"><a href="/interview/设计模式/" class="nav-link">
  设计模式
</a></div><div class="nav-item"><a href="/interview/工作积累/" class="nav-link">
  工作积累
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="源码学习" class="dropdown-title"><span class="title">源码学习</span> <span class="arrow down"></span></button> <button type="button" aria-label="源码学习" class="mobile-dropdown-title"><span class="title">源码学习</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/源码学习/vue3.html" class="nav-link">
  vue3
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浏览器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#cookie-session-webstorage-localstorage-sessionstorage" class="sidebar-link">cookie, session, webStorage(localStorage, sessionStorage)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#dns-解析" class="sidebar-link">DNS 解析</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#浏览器跨域问题" class="sidebar-link">浏览器跨域问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#什么是同源" class="sidebar-link">什么是同源:</a></li><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#为什么会有跨域问题" class="sidebar-link">为什么会有跨域问题:</a></li><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#跨域问题描述和解决方案" class="sidebar-link">跨域问题描述和解决方案:</a></li></ul></li><li><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#浏览器工作原理" class="sidebar-link">浏览器工作原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#如何在-chrome-中查看-css-有关内容" class="sidebar-link">如何在 chrome 中查看 css 有关内容</a></li></ul></li><li><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#重绘与重排" class="sidebar-link">重绘与重排</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#浏览器的缓存" class="sidebar-link">浏览器的缓存</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#浏览器中的-fetch-和我们的-axios的区别" class="sidebar-link">浏览器中的 fetch 和我们的 axios的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#fetch" class="sidebar-link">fetch</a></li><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#axios" class="sidebar-link">axios</a></li></ul></li><li><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#多页面应用中的通信" class="sidebar-link">多页面应用中的通信</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#_1-使用-localstorage" class="sidebar-link">1. 使用 localStorage</a></li><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#_2-使用-cookie" class="sidebar-link">2. 使用 cookie</a></li><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#_3-使用-websocket" class="sidebar-link">3. 使用 webSocket</a></li><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#_4-使用-share-worker" class="sidebar-link">4. 使用 share worker</a></li></ul></li><li><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#浏览器中的-dom-api" class="sidebar-link">浏览器中的 DOM API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#childnodes-vs-children" class="sidebar-link">childNodes vs children</a></li><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#其他高级-api" class="sidebar-link">其他高级 Api</a></li><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#rangeapi" class="sidebar-link">RangeApi</a></li><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#cssapi" class="sidebar-link">cssApi</a></li></ul></li><li><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#浏览器中的-冒泡和捕获" class="sidebar-link">浏览器中的 冒泡和捕获</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/%E6%B5%8F%E8%A7%88%E5%99%A8/#dom0-级和-dom2-级事件" class="sidebar-link">Dom0 级和 Dom2 级事件</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h1> <h2 id="cookie-session-webstorage-localstorage-sessionstorage"><a href="#cookie-session-webstorage-localstorage-sessionstorage" class="header-anchor">#</a> cookie, session, webStorage(localStorage, sessionStorage)</h2> <ul><li><p>Cookie：一种网页存储技术, 与 webStorage 想对应</p> <ol><li>cookie 数据始终在同源的 http 请求中携带, 而 session 和 localStorage 则不会</li> <li>cookie 是有生命期的, 在生命期内, 即使关闭浏览器也有效,不会丢失,若没有设置生命期, 则关闭窗口 cookie 就消失了, 里面的东西也就没有了.</li> <li>所有<strong>同源窗口</strong>共享 cookie 存储的 token 信息</li> <li>来源于服务器端, 以文本的形式保存在客户端, 可以与服务器交互, 不能存超过 4kb 的信息.
在请求报文中, set-cookie 字段, 之后 客户端请求都会在 http 协议的头文件中设置 cookie 字段</li> <li>cookie 有路径区分概念, 不同的路径, cookie 都是不一样的, cookie 里面记录的东西也就不一样</li></ol></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//  用 cookie 给记录下来</span>
document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">&quot;age = 18&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 这样我们就能把一个 name 为 username, value 为 XX 的值给记录下来,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/interview/assets/img/cookie.d0729039.png" alt="cookie"></p> <ul><li><p>session:</p> <ol><li>session 保存在服务器端, HashTable 形式来存储, 没有大小限制</li> <li>服务器发根据自己的 session 检查 是否有这个 sessionId, 如果没有就给客户端一个 sessionId</li></ol></li> <li><p>知识点串联: 登录系统</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>当我们登录的时候, 服务器会检查我们的请求中是否有 sessionId(客户端以 cookie 形式保存), 如果在服务器端中的 session 列表中没有,那么就会让我们 输入账号密码, 如果正确给客户端一个 sessionId, 同时服务器会记录下这个 sessionId 在自己的 session 中. 而此时客户端会以次 sessionId 以 cookie 的形式记录下来. 下次登录的时候, 直接请求带上这个 sessionId, 这样客户端检查 sessionId 是在自己的 session 中的,然后就不需要让客户端输入账号密码了, 因为之前已经做过校验了, 直接返回该 sessionId 对应的 session 对象</p></div> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>如果客户端不支持使用 cookie 的话, 那么我们就需要在 url 请求中用 url + sessionId (url 拼接的形式)来请求了, 相当于把参数加到 url 后面
例子: www.baidu.com/?sessionId=XNEIG123</p></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>WebStorage = localStorage + sessionStorage</code> 组成, 是针对 cookie 的劣势而在 HTML5 中做的优化,现在有很多的浏览器主要是把我们的 <code>sessionId</code> 不在存入 cookie 中,而是存入到 webStorage 当中</p></div></li> <li><p>localStorage:</p> <ol><li>始终有效, 即使浏览器关闭也有效</li> <li>所有同源窗口共享</li> <li>不是与服务器交互的</li> <li>js 做的本地化存储</li> <li>字符串类型, 可以 <code>JSON.stringify()</code></li></ol></li> <li><p>sessionStorage:</p> <ol><li>将数据保存在 session 对象中,这里的 session 就是值用户在浏览某个网站的时候, 进入到这个网站到 X 掉这个页面,
即使刷新或者进入另一个同源页面, 也不会消失,因为这都算是一个 session 内</li> <li>数据是临时的保存</li> <li>不与服务器进行交互通信</li> <li>字符串类型, 可以 <code>JSON.stringify()</code></li></ol> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>WkWebview 和 android 的 webview 也是可以做本地化储存的,但是会有几点问题</p> <ol><li>不要用 Local Storage 来做持久化存储，在 iOS 中，出现存储空间紧张时，它会被系统清理掉；</li> <li>不要用 Local Storage 来存大量数据，它的读写效率很低下，因为它需要序列化/反序列化, 可能还没有网络请求来的快；</li> <li>大小限制为 5M</li></ol></div></li></ul> <h2 id="dns-解析"><a href="#dns-解析" class="header-anchor">#</a> DNS 解析</h2> <p>a）首先会搜索浏览器自身的 DNS 缓存（缓存时间比较短，大概只有 1 分钟，且只能容纳 1000 条缓存）</p> <p>b）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的 DNS 缓存</p> <p>c）如果还没有找到，那么尝试从 hosts 文件里面去找</p> <p>d）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找，具体过程如下</p> <p><img src="/interview/assets/img/5rxqugj8dh.09eab176.png" alt="dns域名解析"></p> <h2 id="浏览器跨域问题"><a href="#浏览器跨域问题" class="header-anchor">#</a> 浏览器跨域问题</h2> <h3 id="什么是同源"><a href="#什么是同源" class="header-anchor">#</a> 什么是同源:</h3> <p>浏览器自带的同源策略: 协议+host+(域名,ip)+端口. 只要满足这个, 就是同源</p> <h3 id="为什么会有跨域问题"><a href="#为什么会有跨域问题" class="header-anchor">#</a> 为什么会有跨域问题:</h3> <ol><li>发生在浏览器, 浏览器的一个防御措施</li> <li>产生原因是: 就是因为我们要在两个不同源的地方去请求数据, 例如在百度当前页面去请求 google, 这个时候浏览器会判断我们是跨域行为,浏览器会禁止当前的百度请求 google 行为</li></ol> <h3 id="跨域问题描述和解决方案"><a href="#跨域问题描述和解决方案" class="header-anchor">#</a> 跨域问题描述和解决方案:</h3> <h4 id="_1-cros-方式"><a href="#_1-cros-方式" class="header-anchor">#</a> 1. <code>CROS</code> 方式</h4> <blockquote><p>服务器设置通过响应头文件添加字段</p></blockquote> <ol><li><p>当 A 页面发送请求到 B 页面的网站的时候,浏览器先问下 B 页面的网站是否允许请求跨域, 在百度页面上有一个发送 ajax 请求, 访问 google. 浏览器会先询问 google 上的服务器是否允许从百度页面上发来的 ajax 请求. 这个时候浏览器会发送 <strong>option</strong> 请求, 去询问 google 服务器, 如果 google 发送的响应报文中 有
<code>Access-Control-Allow-Origin</code>中包含百度的这个域名, 这样浏览器就会发送 Get 请求. 注意这个 是第二次才发送的, 真正的请求文件. 如果 google 不允许, 则这第二次的请求就不会发送. 同时浏览告诉你, 在百度这个页面访问 google 的请求跨域了. 不好的就是, 每一次我们发送 get 请求, 浏览器都会去询问 google 是否支持跨域, 这样相当于每次一 Get 请求 = 发送两个请求(一个是询问请求, 一个是真的 Get 请求)</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><code>Access-Control-Allow-Origin</code>如果设置了具体的域名, 那么就<strong>只能设置一个</strong>(不好的地放),如果需要设置多个 只能用通配符 *, 如果用了* 就能不能携带 cookie(浏览器为了安全设置)</p></div></li> <li><p>还有一种是 <code>Access-Control-Max-Age</code>, 这种是在第一次发送询问请求之后的多少 s 之内, 都可以不用再次询问了,直接可以发送普通的请求, 这样就免掉了每次发请求都要发询问, 大大增加沟通效率</p></li> <li><p><code>Access-Control-Allow-Method</code>: 允许跨域的方法,例如允许 Get</p></li> <li><p><code>Access-Control-Allow-Header</code>: 允许哪些请求头才能跨域</p></li></ol> <h4 id="_2-proxy-方式-前端利用-node-中间件代理-或者后端用-nginx"><a href="#_2-proxy-方式-前端利用-node-中间件代理-或者后端用-nginx" class="header-anchor">#</a> 2. proxy 方式(前端利用 node 中间件代理, 或者后端用 nginx)</h4> <blockquote><p>网页发送请求到我们的同源服务器代理, 由代理服务器替代我们去访问别的服务器.</p></blockquote> <ol><li><p>例如我们在百度页面发送 ajax 请求到 google, 我们可以去访问百度服务器, 百度服务器可以设置一个代理, 拦截我们要取访问 google 的这个 ajax 请求, 然后由百度服务器去访问 google 服务器, 因为服务器和服务器之间没有跨域这个问题. 所以当百度服务器替我们去拿数据,在返给客户端展示</p></li> <li><p>正向代理: 类似于 VPN, 我们登录上我们的 VPN 之后, 我们输入 google, 可以明确的告诉浏览器我就要去 google 访问, 那么我们会走一个代理服务器, 但是我们不知道是哪一个代理服务器帮我们翻墙, 我们的最终目的地是受客户端控制的,</p></li> <li><p>反向代理: 我明确去访问代理服务器,代理服务器自己决定去哪里访问, 客户端无法控制, 最终目的地客户端无法控制, 通常反向代理域 都会有 api 字段在 url 当中</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p></div></li> <li><p>vue 中用的就是 反向代理, 用 node 起了一个代理服务器,帮我们去访问</p></li> <li><p>webpack 也是这样的
<img src="/interview/assets/img/webpack_proxy.9c8dd635.png" alt="webpack代理处理跨域问题"></p> <p>:::</p></li></ol> <h4 id="_3-jsonp-方式"><a href="#_3-jsonp-方式" class="header-anchor">#</a> 3. Jsonp 方式</h4> <blockquote><p>html 中有一些天然支持跨域的标签, 我们就可以利用这个技术, 重点理解原理,和实现方法. 现在不经常使用了</p></blockquote> <ol><li><p>首先我们在前端 A 页面声明一个函数 <code>function A(dataFromPageB)</code></p></li> <li><p>然后我们在 A 页面中利用 script 标签这个天然支持跨域请求, 通过 src 去请求 pageB, 通常会把这个函数拼接到 url 请求当中</p></li> <li><p>pageB 页面只需要在返回的请求中 返回<strong>字符串</strong> <code>A(dataWannaCross)</code>, 当 pageA 拿到这个请求的文件的时候, 会自动执行 <code>function A</code></p></li> <li><p>因为 script 标签只支持 get, 不支持 post, 所以 JSONp 也仅仅支持 get 请求(这个是不好的地方)</p></li> <li><p>安全性会降低, 因为如果服务器被黑了,返回的是木马程序, 那么我们前端也是会执行</p></li> <li><p>其他类似标签: <code>img</code>, <code>iframe</code>, <code>link</code>, 这些都不存在跨域请求的限制</p></li> <li><p>jsonp 需要有服务端的支持</p> <p><img src="/interview/assets/img/jsonp.18c34a73.png" alt="jsonp原理"></p></li></ol> <p><strong>总结</strong>: JSONp 相当于是 PageB 通过服务器返回函数名字( functionA(参数) ) 帮我们自动激活了 PageA 里面的我们命名的方法</p> <h4 id="_4-postmessage-方式-iframe-不常用"><a href="#_4-postmessage-方式-iframe-不常用" class="header-anchor">#</a> 4. postMessage 方式 + iframe (不常用)</h4> <ol><li>利用 iframe, 在页面中嵌入一个隐藏的 iframe,这个 iframe src 指向我们要请求的地址的 html</li> <li>利用 postMessage 与 iframe src 执行的网页进行通信</li> <li>iframe 会阻塞加载</li></ol> <h4 id="_5-websocket-也能支持跨域请求数据"><a href="#_5-websocket-也能支持跨域请求数据" class="header-anchor">#</a> 5. webSocket 也能支持跨域请求数据</h4> <h4 id="_6-document-domain-iframe"><a href="#_6-document-domain-iframe" class="header-anchor">#</a> 6. document.domain + iframe</h4> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>该方法只能实现同一个主域, 不同子域的请求</p></div> <h4 id="_7-window-name-iframe"><a href="#_7-window-name-iframe" class="header-anchor">#</a> 7. window.name + iframe</h4> <ol><li>A 页面嵌入 iframe, 该 iframe 去访问 B 的 window.name(我们可以让 window.name 可以赋值我们需要的数据)</li> <li>因为访问不同源的 window.name 浏览器会去禁止, 那么我只需要在 A 页面拿到 B 返回的 window.name 之前, 让 A 页面的 iframe src 指向一个同源的文件(proxy.html)就可以避免掉
<img src="/interview/assets/img/window.name.5666cc6d.png" alt="window.name + iframe"></li></ol> <h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="header-anchor">#</a> 浏览器工作原理</h2> <ol><li>拿到请求的 html 文件</li> <li>解析 html, 同时如果有引用, 就那么就去下载我们的引用(js 文件, css 文件)</li> <li>生成 html DOM 树 (document), 生成 CSS 渲染树(styleSheets document)</li> <li>结合 两个树生成一个 html 树</li> <li>计算位置和尺寸(重绘)</li> <li>渲染呈现界面 (重排)</li></ol> <p><img src="/interview/assets/img/exploer.3375a211.png" alt="浏览器工作流程"></p> <h3 id="如何在-chrome-中查看-css-有关内容"><a href="#如何在-chrome-中查看-css-有关内容" class="header-anchor">#</a> 如何在 chrome 中查看 css 有关内容</h3> <ol><li>在 inspection 中的 Elements 按钮, 我们的 style 标签下面会有该 element 的 style</li> <li>element 的 style 中的来源如果是 userAgent 代表的是使用的是默认来源</li></ol> <h2 id="重绘与重排"><a href="#重绘与重排" class="header-anchor">#</a> 重绘与重排</h2> <ol><li>先发重排, 在发生重绘</li> <li>重绘是例如 background 的改变等等, 而重排则是发生 dom 节点, 或者 size 等物理尺寸发生变化, 浏览不得不重新计算该元素的位置</li></ol> <h2 id="浏览器的缓存"><a href="#浏览器的缓存" class="header-anchor">#</a> 浏览器的缓存</h2> <blockquote><p>次针对的的是 响应头文件, 服务器响应客户端的请求,理论上来说这个是双向的, 响应报文和请求报文都会有</p></blockquote> <ol><li><p>强缓存</p> <ul><li><p>当我们建立连接的时候, 浏览器会看响应请求的缓存时间, 如果响应请求的字段<code>Expires</code>没有过期. 那么<code>客户端第二次请求</code>的时候(例如刷新), 就不用再发发请求到服务器去拿资源, 就是强缓存.</p></li> <li><p><code>Expires 是一个绝对时间</code>, 这样当我们的系统时间被改变之后, 我们的会出现缓存混乱的情况</p></li> <li><p><code>cache-control:max-age 3600</code> 是一个相对时间, 例如,在这次请求的之内的 3600 秒, 都是可以使用缓存的. 他用来弥补 <code>Expires</code>的不足</p></li> <li><p>可以大大减少服务器的压力</p></li></ul></li> <li><p>协商缓存</p></li></ol> <ul><li>当我们的浏览器发现这次的请求过了缓存时间(此时浏览器认为该缓存不能用了), 那么浏览器就会问服务器拿资源,让服务器去帮忙判断是否可以用缓存, 于是服务器一看没有更新,就让浏览器还是取用缓存,(表现形式是没有返回响应, 或者 304)</li> <li>last-modify / if-modify-since, 是服务器给浏览器告诉浏览器自己这边缓存的时间期限, 第一次请求返回的是 last-modify, 下一次响应报文则是<code>if-modify-since</code>, 精确到 s</li> <li>因为 last- modify 和 if-modify-since 是依靠的是绝对时间, 因此缠身了 ETag, 类似于 git 的版本号, ETag 保证每一个资源时唯一的, 因此当 ETag 发生了变化,我们可以知道服务器那边的资源发生了变化, ETag 大大提高了 modify 时间精度不准备 的问题</li></ul> <p>场景总结:
当我们第一次请求的时候, 客户端得到的响应报文中会加入 cache control: max-age 等字样, 告诉我们客户端在多少 s 之内,如果在次发起请求(例如:刷新)的时候, 可以直接用缓存, 不需要真正的发送请求过来. 所以当我们的浏览器在刷新的时候, 会采用强缓存, 直接在本地读取,不发送请求给服务器. 当我们第三次刷新页面(这个时候已经超过了服务器给的 max-age 生命时间 ).我们的客户端不知到是否在服务器上发生了更新, 这个时候浏览器会请求服务器问服务器要数据, 会拿上第一次服务器发过来的 ETag 作为 请求报文中的<code>If-None-Match</code>, 去求情服务器. 这个时候服务器一看我这边没有发生跟新, 就会发送 304 给浏览器(相当用户告诉浏览器, 我这边没有更新, 你还是可以用上一次的缓存.). 第三次就是我们的协商缓存. 如果服务器有更新, 那么响应报文中就会返回 200 , 发送新的 ETag 告诉我们浏览器这个是新的, 我们去更新.</p> <hr> <p>这个就是第一的 response 和第二的 request 和 response</p> <p><img src="/interview/assets/img/cache1.ecc1c908.png" alt="当服务器没有发生变化使得协商缓存"></p> <hr> <p>这个就是第一的 response 和第二的 request 和 response</p> <p><img src="/interview/assets/img/cache2.b28f9d7c.png" alt="当服务器发生变化用的协商缓存"></p> <h2 id="浏览器中的-fetch-和我们的-axios的区别"><a href="#浏览器中的-fetch-和我们的-axios的区别" class="header-anchor">#</a> 浏览器中的 <code>fetch</code> 和我们的 <code>axios</code>的区别</h2> <h3 id="fetch"><a href="#fetch" class="header-anchor">#</a> fetch</h3> <ul><li><p>fetch 是一个我们浏览器自带的底层 api, 他支持 es6 的 Promise 语法, 比较糙, 需要我们自己进行封装</p></li> <li><p>不支持进度检测, 当我们上传大文件的时候,我们希望看到进度条</p></li> <li><p>不支持区分 400 和 500 的 区分</p></li> <li><p>fetch 和 XMLHttpRequest 是一个级别的, 都是属于底层 api</p></li></ul> <h3 id="axios"><a href="#axios" class="header-anchor">#</a> axios</h3> <ul><li>axios 是一个更高级的封装, 自带 cookie 等,已经被配置好的网络请求框架</li> <li>有上传进度检测, 我们可以来根据这个回调,来制作上传进度条</li> <li>可以在服务器端(node)使用, 也可以在客户端使用</li> <li>自动转换 JSON 数据</li> <li>支持拦截请求</li></ul> <h2 id="多页面应用中的通信"><a href="#多页面应用中的通信" class="header-anchor">#</a> 多页面应用中的通信</h2> <h3 id="_1-使用-localstorage"><a href="#_1-使用-localstorage" class="header-anchor">#</a> 1. 使用 <code>localStorage</code></h3> <blockquote><ol><li>在一个标签页里面使用 localStorage.setItem(name, val)添加,修改内容</li> <li>另一个页面去监听 storage 时间, 可以得到 localStorage 存储的值, 实现不同标签页面之间的通信 <code>window.addEventListener('storage', function)</code></li> <li>必须得是在同源,如果想要不同域名之下, 需要在 A 页面嵌入 B 页面(另一个域名), 来获取</li></ol></blockquote> <h3 id="_2-使用-cookie"><a href="#_2-使用-cookie" class="header-anchor">#</a> 2. 使用 <code>cookie</code></h3> <blockquote><ol><li>A 页面存储信息到 cookie 中, B 页面轮询查看 A 页面中的 cookie 是否有存储更新</li> <li>A 页面 <code>document.cookie = 'name=' + value</code></li> <li>B 页面每过一段时间去轮询 document.cookie
不一个域名下的无法共享</li></ol></blockquote> <h3 id="_3-使用-websocket"><a href="#_3-使用-websocket" class="header-anchor">#</a> 3. 使用 <code>webSocket</code></h3> <blockquote><ol><li>全双工, 建立 webSocket 连接之后, 服务器可以主动发消息给客户端</li> <li>H5 新特性</li></ol></blockquote> <h3 id="_4-使用-share-worker"><a href="#_4-使用-share-worker" class="header-anchor">#</a> 4. 使用 <code>share worker</code></h3> <blockquote><ol><li>引入 worker.js</li> <li>可以实现多标签, iframe 共同使用. sharedWorker 可以在是被多个 window 共同使用,但是必须保证这些标签页是同源的(相同的协议, 主机和端口)</li></ol></blockquote> <h2 id="浏览器中的-dom-api"><a href="#浏览器中的-dom-api" class="header-anchor">#</a> 浏览器中的 DOM API</h2> <p>对于浏览器而言,所有的节点都是 node 节点, 而 Dom api 就是给我提供这样的 api 去操纵这些 node</p> <h3 id="childnodes-vs-children"><a href="#childnodes-vs-children" class="header-anchor">#</a> childNodes vs children</h3> <ul><li><p>childNode 是所有的 children node 节点(文本节点, 空白节点(null), element 节点, comment 节点)</p></li> <li><p>children 是特指所有 element 属性的 node 节点(排除了文本节点, 空白节点, comment 节点)</p></li></ul> <h3 id="其他高级-api"><a href="#其他高级-api" class="header-anchor">#</a> 其他高级 Api</h3> <ul><li>compareDocumentPosition : 是一个用于比较两个节点中关系的函数</li> <li>contains: 检查一个节点是否包含另一个节点的函数</li> <li>isEqualNode: 检查两个节点是不是完全相同(还是两个节点, 只是他们是不是一样的, ==)(相当于检查是不是双胞胎)</li> <li>isSameNode: 检查两个节点是不是同一个节点(===完全可以代替)(相当于检查是不是同一个人)</li> <li>cloneNode: 复制一个节点, 如果参数为 true, 则连同子元素做深拷贝</li></ul> <h3 id="rangeapi"><a href="#rangeapi" class="header-anchor">#</a> RangeApi</h3> <ul><li><code>range.extractContents()</code> 可以得到 fragment, fragment 可以做很多操作</li> <li><code>range()</code>函数可以把 dom 节点拿下来, 然后操作这段 fragment, 这样不会频繁引起重绘和重排, 然后再把 fragment 给添加上去</li></ul> <h3 id="cssapi"><a href="#cssapi" class="header-anchor">#</a> cssApi</h3> <ul><li><code>document.styleSheets</code> 返回一个列表, 一个 css 文件就是一个项 或者一个 css link 就是一项</li> <li><code>getComputedStyle</code> 用来获取当时作用在 dom 上的所有样式, 所以当我们需要获取一些中间状态的 css 例如, 动画某一瞬间的动画设置, 或者拖拽, 可以用 getComputedStyle 非常好用</li> <li><code>getClientRects()</code> 用来获取该 dom 里面的所有的盒</li> <li><code>getBoundingClientRect</code> 用来获取该 dom 的包裹所有的盒的最外面的盒子</li></ul> <h2 id="浏览器中的-冒泡和捕获"><a href="#浏览器中的-冒泡和捕获" class="header-anchor">#</a> 浏览器中的 冒泡和捕获</h2> <h3 id="dom0-级和-dom2-级事件"><a href="#dom0-级和-dom2-级事件" class="header-anchor">#</a> Dom0 级和 Dom2 级事件</h3> <ul><li>dom0 级事件 都是以 on 为开头的事件, 如果一个 div 有多个 相同的 dom0 级事件(例如 onclick) 会覆盖,只执行最后一个 dom0 级事件, Dom0 级之后冒泡阶段, 无法定义捕获</li> <li>dom2 级事件,则不会付过, 按顺序执行, 可以定义捕获和冒泡</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/interview/assets/js/app.4760c636.js" defer></script><script src="/interview/assets/js/2.fcc25b9e.js" defer></script><script src="/interview/assets/js/3.1d9d2a9b.js" defer></script>
  </body>
</html>
