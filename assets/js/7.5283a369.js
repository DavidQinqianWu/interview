(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{364:function(t,s,_){t.exports=_.p+"assets/img/http2.0740ab61.png"},365:function(t,s,_){t.exports=_.p+"assets/img/responseCode.8bff4d1e.png"},383:function(t,s,_){"use strict";_.r(s);var v=_(45),e=Object(v.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"网络"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[t._v("#")]),t._v(" 网络")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("前端而言, 网络往往伴随着浏览器一起说出, 而网络是前端不可或缺需要了解, 因为这与大厂考察的优话是息息相关的")])]),t._v(" "),v("h2",{attrs:{id:"http-1-1-http-2-0-websocket-https"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-http-2-0-websocket-https"}},[t._v("#")]),t._v(" http 1.1 / http 2.0/ webSocket / https")]),t._v(" "),v("h3",{attrs:{id:"http-1-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" http 1.1")]),t._v(" "),v("ul",[v("li",[t._v("长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。但是请求还是一次一次进行的, 完成这个请求才能开始下个")])]),t._v(" "),v("h3",{attrs:{id:"http-2-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0"}},[t._v("#")]),t._v(" http 2.0")]),t._v(" "),v("ul",[v("li",[t._v("服务端推送（server push）HTTP2.0 有 server push 功能, 例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.css 的文件推送给客户端，当客户端再次尝试获取 sytle.css 时就可以直接从"),v("code",[t._v("缓存")]),t._v("中获取到，不用再发请求了")]),t._v(" "),v("li",[t._v("可以同时发送多个请求,如果有一个请求的时间特别长,不会影响另外的请求")]),t._v(" "),v("li",[t._v("压缩 http 协议的头文件, 减少请求体积")])]),t._v(" "),v("p",[v("img",{attrs:{src:_(364),alt:"http2"}})]),t._v(" "),v("h3",{attrs:{id:"websocket"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" webSocket")]),t._v(" "),v("p",[t._v("webSocket 是针对 http1.1 做的进一步改进, 能够让双方间建立实施的双向通信,WebSocket 的最大特点就是，"),v("strong",[t._v("服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息")]),t._v("，是真正的双向平等对话")]),t._v(" "),v("p",[t._v("WebSocket 的其他特点：")]),t._v(" "),v("ul",[v("li",[t._v("建立在 TCP 协议之上，服务器端的实现比较容易。")]),t._v(" "),v("li",[t._v("与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。")]),t._v(" "),v("li",[t._v("数据格式比较轻量，性能开销小，通信高效。")]),t._v(" "),v("li",[t._v("可以发送文本，也可以发送二进制数据。")]),t._v(" "),v("li",[t._v("没有同源限制，客户端可以与任意服务器通信。")]),t._v(" "),v("li",[t._v("协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。")])]),t._v(" "),v("h3",{attrs:{id:"https"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" https")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("http + 机密+ 认证+ 完整性保护 = https")]),t._v(", 是 http + SSL")]),t._v(" "),v("li",[t._v("公开密钥加密: 是一种公开加密的技术, 相当于我自己有一个本地的私钥, 然后我还有一个在共享功能的公钥, 任何人要给我发信息, 都可以用这个公钥进行加密, 然后加密之后的解密只有这个私钥才能解开")]),t._v(" "),v("li",[t._v("共享秘钥加密 : 速度快, 安全性差. 相当两者之间保留自己的钥匙, 公用一个锁")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("https 采用两者混合的模式, 在初次建立连接交换共享秘钥的时候应该是采用, 公开密钥加密方式, 这样当两个安全的拿到共享秘钥的口令之后, 就可以采用共享秘钥加密进行交流, 因为他们之间传播速度更快")])]),t._v(" "),v("h2",{attrs:{id:"描述一次完整的-http-请求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#描述一次完整的-http-请求"}},[t._v("#")]),t._v(" 描述一次完整的 HTTP 请求")]),t._v(" "),v("h3",{attrs:{id:"_1-dns-如何找到域名"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-dns-如何找到域名"}},[t._v("#")]),t._v(" 1. DNS 如何找到域名")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("DNS 域名解析采用"),v("strong",[t._v("递归查询")]),t._v(".过程: 首先去找 DNS 缓存 => 缓存如果没有就找根域名服务器 => 根域名服务器又会去找下一级. 这样递归查找之后,就找到我们的 web 浏览器要访问的服务器")])]),t._v(" "),v("li",[v("p",[t._v("DNS 也可以采用"),v("strong",[t._v("迭代查询")]),t._v(". 迭代查询就是, 我们查询根服务器, 根服务器告诉我们下一级的服务器的 ip 地址, 我们自己需要主动去下一级查询")])]),t._v(" "),v("li",[v("p",[t._v("为了减少根服务器的压力, 通常会设置缓存. 例如 物理学院的电脑会先到清华大学的与域服务器访问,如果与服务器发现之前有人已经访问过 baidu 的域名, 那么与服务器就会直接给返回对应的 ip 地址, 这样域服务器就不用再去访问那个根服务器了, 减少了访问次数")])])]),t._v(" "),v("h3",{attrs:{id:"_2-三次握手-建立-tpc-连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-三次握手-建立-tpc-连接"}},[t._v("#")]),t._v(" 2. 三次握手, 建立 TPC 连接")]),t._v(" "),v("h3",{attrs:{id:"_3-发送-http-协议-应用层-请求-http-页面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-发送-http-协议-应用层-请求-http-页面"}},[t._v("#")]),t._v(" 3. 发送 HTTP 协议 (应用层), 请求 http 页面")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("在 http 协议中,有常见的几个文段,connection, user-agent 还有 cookie 字段等等")])]),t._v(" "),v("li",[v("p",[t._v("我们会得到响应码, 常见的响应码有\n"),v("img",{attrs:{src:_(365),alt:"响应状态码"}})])]),t._v(" "),v("li",[v("p",[t._v("常见的 14 种 :")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("200 - 成功")])]),t._v(" "),v("li",[v("p",[t._v("204 - no content 表示已经成功,但是响应报文中没有 body 部分")])]),t._v(" "),v("li",[v("p",[t._v("206 - 表示服务器已经对部分请求给与了响应")])]),t._v(" "),v("li",[v("p",[t._v("301 - 表示你的这个请求已经被永久改变了位置. 所以在给 301 的时候, 响应报文中的 location 字段会给新的 url")])]),t._v(" "),v("li",[v("p",[t._v("302 - 表示你请求的这个已经被临时改变了位置.")])]),t._v(" "),v("li",[v("p",[t._v("303 - 与 302 一样, 同时告诉浏览器已经采用 GET 方法去获取这个新的 url")])]),t._v(" "),v("li",[v("p",[t._v("304 - 服务器告知代你请求的东西没有更新, 客户端你可以使用缓存, 协商缓存")])]),t._v(" "),v("li",[v("p",[t._v("400 - 服务器不理解请求的语法(通常是我们客户端发送的请求参数不对)")])]),t._v(" "),v("li",[v("p",[t._v("401 - 当前请求需要进行身份验证")])]),t._v(" "),v("li",[v("p",[t._v("500 - 服务器遇到错误, 无法完成请求")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://blog.csdn.net/qq_37960324/article/details/83374855",target:"_blank",rel:"noopener noreferrer"}},[t._v("状态码详解:"),v("OutboundLink")],1)])])])])]),t._v(" "),v("h3",{attrs:{id:"_4-四次挥手断开连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-四次挥手断开连接"}},[t._v("#")]),t._v(" 4. 四次挥手断开连接")])])}),[],!1,null,null,null);s.default=e.exports}}]);